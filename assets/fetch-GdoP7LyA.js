import{r as p,R as _t}from"./index-DyOiOGPz.js";import{g as Xt}from"./utils-CmQ-S6PF.js";const He={login:()=>"/loginWeb",changePassword:()=>"/changePassword",validChangePassword:()=>"/changePassword/validatetfa",forgotPassword:()=>"/forgotPassword",validForgotPassword:()=>"/forgotPassword/validate",register:()=>"/register",requestVerifyEmail:()=>"/verifyEmail",verifyEmail:()=>"/validateVerifyEmail",requestDuplicateVerify:()=>"/active2fa",duplicateVerify:()=>"/validate2fa",validateLogin:()=>"/login/validatetfa",acb:()=>"/getBankQrCode",mb:()=>"/getMBBankQrCode",servers:()=>"/serverlist",players:()=>"/playerlist",coinInfo:()=>"/coininfo",transferCoin:()=>"/convertCoin",transferRate:()=>"/convertrateinfo",validTransfer:()=>"/convertCoin/validatetfa",requestClearBag:()=>"/clearBagPassword",validClearBag:()=>"/clearBagPassword/validatetfa",transferHistory:()=>"/chargeHistory",changeEmail:()=>"/changeEmail",validChangeEmail:()=>"/changeEmail/confirmvalidatetfa",deActive2fa:()=>"/deactive2fa",validDeActive2fa:()=>"/validatedeactive2fa"};var Mt={exports:{}},Ut={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var G=p;function Zt(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var te=typeof Object.is=="function"?Object.is:Zt,ee=G.useState,ne=G.useEffect,se=G.useLayoutEffect,re=G.useDebugValue;function oe(t,e){var n=e(),o=ee({inst:{value:n,getSnapshot:e}}),s=o[0].inst,i=o[1];return se(function(){s.value=n,s.getSnapshot=e,lt(s)&&i({inst:s})},[t,n,e]),ne(function(){return lt(s)&&i({inst:s}),t(function(){lt(s)&&i({inst:s})})},[t]),re(n),n}function lt(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!te(t,n)}catch{return!0}}function ie(t,e){return e()}var ae=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?ie:oe;Ut.useSyncExternalStore=G.useSyncExternalStore!==void 0?G.useSyncExternalStore:ae;Mt.exports=Ut;var ce=Mt.exports;const M=()=>{},O=M(),ft=Object,a=t=>t===O,N=t=>typeof t=="function",U=(t,e)=>({...t,...e}),ue=t=>N(t.then),rt=new WeakMap;let le=0;const Z=t=>{const e=typeof t,n=t&&t.constructor,o=n==Date;let s,i;if(ft(t)===t&&!o&&n!=RegExp){if(s=rt.get(t),s)return s;if(s=++le+"~",rt.set(t,s),n==Array){for(s="@",i=0;i<t.length;i++)s+=Z(t[i])+",";rt.set(t,s)}if(n==ft){s="#";const c=ft.keys(t).sort();for(;!a(i=c.pop());)a(t[i])||(s+=i+":"+Z(t[i])+",");rt.set(t,s)}}else s=o?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},F=new WeakMap,dt={},ot={},Tt="undefined",it=typeof window!=Tt,Rt=typeof document!=Tt,fe=()=>it&&typeof window.requestAnimationFrame!=Tt,qt=(t,e)=>{const n=F.get(t);return[()=>!a(e)&&t.get(e)||dt,o=>{if(!a(e)){const s=t.get(e);e in ot||(ot[e]=s),n[5](e,U(s,o),s||dt)}},n[6],()=>!a(e)&&e in ot?ot[e]:!a(e)&&t.get(e)||dt]};let gt=!0;const de=()=>gt,[mt,pt]=it&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[M,M],Ee=()=>{const t=Rt&&document.visibilityState;return a(t)||t!=="hidden"},ve=t=>(Rt&&document.addEventListener("visibilitychange",t),mt("focus",t),()=>{Rt&&document.removeEventListener("visibilitychange",t),pt("focus",t)}),he=t=>{const e=()=>{gt=!0,t()},n=()=>{gt=!1};return mt("online",e),mt("offline",n),()=>{pt("online",e),pt("offline",n)}},Re={isOnline:de,isVisible:Ee},ge={initFocus:ve,initReconnect:he},Pt=!_t.useId,tt=!it||"Deno"in window,me=t=>fe()?window.requestAnimationFrame(t):setTimeout(t,1),Et=tt?p.useEffect:p.useLayoutEffect,vt=typeof navigator<"u"&&navigator.connection,xt=!tt&&vt&&(["slow-2g","2g"].includes(vt.effectiveType)||vt.saveData),St=t=>{if(N(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?Z(t):"",[t,e]};let pe=0;const wt=()=>++pe,Ht=0,Bt=1,jt=2,we=3;var X={__proto__:null,ERROR_REVALIDATE_EVENT:we,FOCUS_EVENT:Ht,MUTATE_EVENT:jt,RECONNECT_EVENT:Bt};async function kt(...t){const[e,n,o,s]=t,i=U({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=i.populateCache;const f=i.rollbackOnError;let E=i.optimisticData;const b=S=>typeof f=="function"?f(S):f!==!1,w=i.throwOnError;if(N(n)){const S=n,h=[],A=e.keys();for(const g of A)!/^\$(inf|sub)\$/.test(g)&&S(e.get(g)._k)&&h.push(g);return Promise.all(h.map(R))}return R(n);async function R(S){const[h]=St(S);if(!h)return;const[A,g]=qt(e,h),[at,r,et,Q]=F.get(e),W=()=>{const V=at[h];return(N(i.revalidate)?i.revalidate(A().data,S):i.revalidate!==!1)&&(delete et[h],delete Q[h],V&&V[0])?V[0](jt).then(()=>A().data):A().data};if(t.length<3)return W();let _=o,D;const H=wt();r[h]=[H,0];const v=!a(E),B=A(),I=B.data,j=B._c,q=a(j)?I:j;if(v&&(E=N(E)?E(q,I):E,g({data:E,_c:q})),N(_))try{_=_(q)}catch(V){D=V}if(_&&ue(_))if(_=await _.catch(V=>{D=V}),H!==r[h][0]){if(D)throw D;return _}else D&&v&&b(D)&&(c=!0,g({data:q,_c:O}));if(c&&!D)if(N(c)){const V=c(_,q);g({data:V,error:O,_c:O})}else g({data:_,error:O,_c:O});if(r[h][1]=wt(),Promise.resolve(W()).then(()=>{g({_c:O})}),D){if(w)throw D;return}return _}}const Ft=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},_e=(t,e)=>{if(!F.has(t)){const n=U(ge,e),o={},s=kt.bind(O,t);let i=M;const c={},f=(w,R)=>{const S=c[w]||[];return c[w]=S,S.push(R),()=>S.splice(S.indexOf(R),1)},E=(w,R,S)=>{t.set(w,R);const h=c[w];if(h)for(const A of h)A(R,S)},b=()=>{if(!F.has(t)&&(F.set(t,[o,{},{},{},s,E,f]),!tt)){const w=n.initFocus(setTimeout.bind(O,Ft.bind(O,o,Ht))),R=n.initReconnect(setTimeout.bind(O,Ft.bind(O,o,Bt)));i=()=>{w&&w(),R&&R(),F.delete(t)}}};return b(),[t,s,b,i]}return[t,F.get(t)[4]]},Te=(t,e,n,o,s)=>{const i=n.errorRetryCount,c=s.retryCount,f=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(i)&&c>i||setTimeout(o,f,s)},Se=(t,e)=>Z(t)==Z(e),[$t,Ce]=_e(new Map),Oe=U({onLoadingSlow:M,onSuccess:M,onError:M,onErrorRetry:Te,onDiscarded:M,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:xt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:xt?5e3:3e3,compare:Se,isPaused:()=>!1,cache:$t,mutate:Ce,fallback:{}},Re),De=(t,e)=>{const n=U(t,e);if(e){const{use:o,fallback:s}=t,{use:i,fallback:c}=e;o&&i&&(n.use=o.concat(i)),s&&c&&(n.fallback=U(s,c))}return n},ye=p.createContext({}),be="$inf$",zt=it&&window.__SWR_DEVTOOLS_USE__,Ve=zt?window.__SWR_DEVTOOLS_USE__:[],Ae=()=>{zt&&(window.__SWR_DEVTOOLS_REACT__=_t)},Ie=t=>N(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],Le=()=>U(Oe,p.useContext(ye)),Ne=t=>(e,n,o)=>t(e,n&&((...i)=>{const[c]=St(e),[,,,f]=F.get($t);if(c.startsWith(be))return n(...i);const E=f[c];return a(E)?n(...i):(delete f[c],E)}),o),Pe=Ve.concat(Ne),xe=t=>function(...n){const o=Le(),[s,i,c]=Ie(n),f=De(o,c);let E=t;const{use:b}=f,w=(b||[]).concat(Pe);for(let R=w.length;R--;)E=w[R](E);return E(s,i||f.fetcher||null,f)},Fe=(t,e,n)=>{const o=e[t]||(e[t]=[]);return o.push(n),()=>{const s=o.indexOf(n);s>=0&&(o[s]=o[o.length-1],o.pop())}};Ae();const Wt=_t.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),ht={dedupe:!0},We=(t,e,n)=>{const{cache:o,compare:s,suspense:i,fallbackData:c,revalidateOnMount:f,revalidateIfStale:E,refreshInterval:b,refreshWhenHidden:w,refreshWhenOffline:R,keepPreviousData:S}=n,[h,A,g,at]=F.get(o),[r,et]=St(t),Q=p.useRef(!1),W=p.useRef(!1),_=p.useRef(r),D=p.useRef(e),H=p.useRef(n),v=()=>H.current,B=()=>v().isVisible()&&v().isOnline(),[I,j,q,V]=qt(o,r),k=p.useRef({}).current,Jt=a(c)?n.fallback[r]:c,Ct=(u,l)=>{for(const T in k){const d=T;if(d==="data"){if(!s(u[d],l[d])&&(!a(u[d])||!s(st,l[d])))return!1}else if(l[d]!==u[d])return!1}return!0},Ot=p.useMemo(()=>{const u=!r||!e?!1:a(f)?v().isPaused()||i?!1:a(E)?!0:E:f,l=C=>{const P=U(C);return delete P._k,u?{isValidating:!0,isLoading:!0,...P}:P},T=I(),d=V(),L=l(T),K=T===d?L:l(d);let m=L;return[()=>{const C=l(I());return Ct(C,m)?(m.data=C.data,m.isLoading=C.isLoading,m.isValidating=C.isValidating,m.error=C.error,m):(m=C,C)},()=>K]},[o,r]),$=ce.useSyncExternalStore(p.useCallback(u=>q(r,(l,T)=>{Ct(T,l)||u()}),[o,r]),Ot[0],Ot[1]),Dt=!Q.current,Kt=h[r]&&h[r].length>0,z=$.data,J=a(z)?Jt:z,nt=$.error,yt=p.useRef(J),st=S?a(z)?yt.current:z:J,bt=Kt&&!a(nt)?!1:Dt&&!a(f)?f:v().isPaused()?!1:i?a(J)?!1:E:a(J)||E,Vt=!!(r&&e&&Dt&&bt),Gt=a($.isValidating)?Vt:$.isValidating,Qt=a($.isLoading)?Vt:$.isLoading,Y=p.useCallback(async u=>{const l=D.current;if(!r||!l||W.current||v().isPaused())return!1;let T,d,L=!0;const K=u||{},m=!g[r]||!K.dedupe,C=()=>Pt?!W.current&&r===_.current&&Q.current:r===_.current,P={isValidating:!1,isLoading:!1},It=()=>{j(P)},Lt=()=>{const y=g[r];y&&y[1]===d&&delete g[r]},Nt={isValidating:!0};a(I().data)&&(Nt.isLoading=!0);try{if(m&&(j(Nt),n.loadingTimeout&&a(I().data)&&setTimeout(()=>{L&&C()&&v().onLoadingSlow(r,n)},n.loadingTimeout),g[r]=[l(et),wt()]),[T,d]=g[r],T=await T,m&&setTimeout(Lt,n.dedupingInterval),!g[r]||g[r][1]!==d)return m&&C()&&v().onDiscarded(r),!1;P.error=O;const y=A[r];if(!a(y)&&(d<=y[0]||d<=y[1]||y[1]===0))return It(),m&&C()&&v().onDiscarded(r),!1;const x=I().data;P.data=s(x,T)?x:T,m&&C()&&v().onSuccess(T,r,n)}catch(y){Lt();const x=v(),{shouldRetryOnError:ct}=x;x.isPaused()||(P.error=y,m&&C()&&(x.onError(y,r,x),(ct===!0||N(ct)&&ct(y))&&(!v().revalidateOnFocus||!v().revalidateOnReconnect||B())&&x.onErrorRetry(y,r,x,Yt=>{const ut=h[r];ut&&ut[0]&&ut[0](X.ERROR_REVALIDATE_EVENT,Yt)},{retryCount:(K.retryCount||0)+1,dedupe:!0})))}return L=!1,It(),!0},[r,o]),At=p.useCallback((...u)=>kt(o,_.current,...u),[]);if(Et(()=>{D.current=e,H.current=n,a(z)||(yt.current=z)}),Et(()=>{if(!r)return;const u=Y.bind(O,ht);let l=0;const d=Fe(r,h,(L,K={})=>{if(L==X.FOCUS_EVENT){const m=Date.now();v().revalidateOnFocus&&m>l&&B()&&(l=m+v().focusThrottleInterval,u())}else if(L==X.RECONNECT_EVENT)v().revalidateOnReconnect&&B()&&u();else{if(L==X.MUTATE_EVENT)return Y();if(L==X.ERROR_REVALIDATE_EVENT)return Y(K)}});return W.current=!1,_.current=r,Q.current=!0,j({_k:et}),bt&&(a(J)||tt?u():me(u)),()=>{W.current=!0,d()}},[r]),Et(()=>{let u;function l(){const d=N(b)?b(I().data):b;d&&u!==-1&&(u=setTimeout(T,d))}function T(){!I().error&&(w||v().isVisible())&&(R||v().isOnline())?Y(ht).then(l):l()}return l(),()=>{u&&(clearTimeout(u),u=-1)}},[b,w,R,r]),p.useDebugValue(st),i&&a(J)&&r){if(!Pt&&tt)throw new Error("Fallback data is required when using suspense in SSR.");D.current=e,H.current=n,W.current=!1;const u=at[r];if(!a(u)){const l=At(u);Wt(l)}if(a(nt)){const l=Y(ht);a(st)||(l.status="fulfilled",l.value=!0),Wt(l)}else throw nt}return{mutate:At,get data(){return k.data=!0,st},get error(){return k.error=!0,nt},get isValidating(){return k.isValidating=!0,Gt},get isLoading(){return k.isLoading=!0,Qt}}},Me=xe(We);function Be(t){const{data:e,error:n,mutate:o,isLoading:s}=Me(t,null,{revalidateOnFocus:!1,revalidateOnReconnect:!1});return{executePost:async c=>{const f=await Xt.post(t,c);return o(f,!1),f},data:e,isLoading:s,isError:n}}export{He as e,Be as u};
